<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html><head>







   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.77 [en] (X11; U; Linux 2.4.22-10mdk i686) [Netscape]"></head><body>

<center>
<h1>
Euler's angles</h1></center>

<p><br>The aim of this exercise is to show an object (defined in the file
in the <b>p1_escena.pov&nbsp; </b>using
<br>Pov-Ray's scene description language) rotating from its original orientation
at t=0 to a new orientation at t=1
<br>specified by means of its&nbsp; 3x3 rotation matrix (you can choose any of the rotation matrices available in the<br>
subdirectory <span style="font-weight: bold;">final</span>).<br>
</p>
<p>The following particular matrix rotation data is provided for testing purposes:<br>

</p>
<p>0.53632&nbsp;&nbsp;&nbsp; -0.30202&nbsp;&nbsp; 0.78813&nbsp; 1st row
<br>0.68301&nbsp;&nbsp;&nbsp;&nbsp; 0.70388&nbsp; -0.19506&nbsp; 2nd row
<br>-0.49583&nbsp;&nbsp;&nbsp; 0.64292&nbsp;&nbsp; 0.58379&nbsp; 3rd row
</p><p>Note that the elements of the test rotation matrix are also stored in the file <b>rijxcolumnes&nbsp; </b><br>
(the
order is first column elements,
then second column and then third).&nbsp;<br>

</p><p>You should start visualising the scene, executing the commands:
</p><p>povray +w800 +h600 +a0.2 p1_escena.pov
<br>xv p1_escena.png
<br>&nbsp;
</p><p>Note that in the renderization, associated to the object and attached to it, there is a reference
<br>
system with
axes in colours red, green and blue.
<br>&nbsp;
</p><p><i>You will have to find out which 3 elementary consecutive rotations</i>
<br><i>R1(z,fi_z) R2(y,fi_y) R3(x,fi_x)&nbsp; will achieve the desired
change in the orientation of</i>
<br><i>the object, and to build an animated sequence of frames which goes
smoothly from the</i>
<br><i>initial orientation (fi_i = 0)&nbsp; at t=0 to the calculated values
fi_i&nbsp; (fi_z,&nbsp; fi_y,&nbsp; fi_x) at t=1.</i>
<br>&nbsp;
</p><p>Complete the following steps:
</p><p>1) Find out the general 3x3&nbsp; rotation matrix expressed in terms
of the 3 variables <i>fi_i</i>
<br><b>(Euler's angles)</b> entering in&nbsp; R1(z,fi_z) R2(y,fi_y) R3(x,fi_x)
(just making the product of
<br>the 3 matrices does it).
</p><p>2) Write down the equations which relate the r_ij values of the general
3x3 matrix to the
<br>fi_z,&nbsp; fi_y,&nbsp; fi_x&nbsp; angles.
</p><p>3) Write an algorithm which allows to find&nbsp; fi_z,&nbsp; fi_y,&nbsp;
fi_x&nbsp; from the r_ij values (see point 5 below)
</p><p>4) Implement it in a program who will read the file <b>rijxcolumnes
</b>and
compute and print the values of
<br>fi_z, fi_y, fi_x&nbsp; and write them into the file fisef.out (separated by commas).
</p><p>5) execute your program, generating the file <b>fisef.out</b>
</p><p>(Note that this file exists already, so that you can check if your programs
works
<br>correctly). If so, then complete the remaining points:
</p><p>6) Have a look into the file <b>p1_verifica.pov</b>, particularly the
lines:
</p><p><b>#fopen Rij "rijxcolumnes" read</b>
<br><b>#read (Rij,r11,r21,r31,r12,r22,r32,r13,r23,r33)</b>
</p><p><b>#fopen Fis "fisef.out" read</b>
<br><b>#read (Fis,f1z,f1y,f1x)</b>
</p><p>The Pov-Ray code reads both the r_ij elements and the Euler's angles
<i>(Fis,f1z,f1y,f1x)</i><b></b>
<br>Note that the desired orientation coming from r_ij is displayed in
the form of a reference
<br>system in grey colour (objecte&nbsp; SRob,&nbsp; Sistema de Referencia
objectiu):
</p><p><b>// Escena</b>
<br><b>object {SRob matrix &lt; r11,r21,r31,r12,r22,r32,r13,r23,r33, 0.0,
0.0, 0.0 &gt; }</b>
<br><b>//</b>
</p><p>and on the other hand the representation of the object (and the coloured
reference system fixed
<br>to it) is based on the Euler angles:
</p><p><b>object{Roda_dentada rotate f1x*x rotate f1y*y rotate f1z*z}</b>
</p><p><b>object {SRef rotate f1x*x rotate f1y*y rotate f1z*z}</b>
</p><p>Note that the first transformation applied to the coordinates of the
object points
<br>is R(x), the second R(y) and the last R(z), i.e., the reverse order
of the one used
<br>in point&nbsp; 1.&nbsp;
</p><p>Render the scene:
</p><p>povray +w800 +h600 +a0.2 p1_verifica.pov
<br>xv p1_verifica.png
</p><p>If everything went well, the grey axis and the colour ones will coincide
(meaning
<br>that the orientation generated by the 3 elementary rotations that you
have calculated
<br>coincides with that specified by the matrix rotation coefficients)
</p><p>7) create a new directory, where you will generate a sequence of images
<br>displaying a continuously varying time dependent orientation. It is
required that at
<br>t=0 the orientation is given by the identity matrix (i.e., that shown
in p1_escena.pov)
<br>whilst at t=1 it must match the final oritentation in p1_verifica.pov.
Pov-Ray uses a
<br>variable named <i>clock</i> whose values are specified in a initialization
file (p1_anim.ini in this
<br>example), so that a single povray code can generate a varying sequence
of images.
</p><p>In order to achieve this, we will substitute the line
</p><p><b>rotate f1x*x&nbsp;&nbsp; rotate f1y*y&nbsp;&nbsp; rotate f1z*z</b>
<br>by
<br><b>rotate Factor*f1x*x&nbsp;&nbsp;&nbsp; rotate Factor*f1y*y&nbsp;&nbsp;&nbsp;
rotate Factor*f1z*z</b>
</p>
<p>where <b>Factor</b>&nbsp; is a <i>clock</i> dependent value which smoothly
changes from
<br>0 to 1 as time goes on.
<br>(This has already been done in the files&nbsp; <b>p1_anim.pov </b>i&nbsp;<b>
p1_anim.ini</b>, and you
<br>just have to modify the parameters in <b>p1_anim.ini </b>related to
the number of frames
<br>contained in the interval between t=0 and t=1).&nbsp;<br>
</p>
<p><br>
The effect of the time value (actual value of the clock variable) on the rendered image<br>
can be examined in a simple manner by means of the +K command line option. For example,<br>
</p>
<p>povray +w800 +h600 +a0.2 +K0.2 p1_anim.pov&nbsp;&nbsp;&nbsp; <br>
</p>
<p>will generate the scene with an actual value of the clock variable equal to 0.2<br>
</p>
<p>Once you are confident that several clock values in the range [0-1] do provide reasonable <br>
results, you can execute
</p>
<p>povray +W640 +H480 +a0.2 p1_anim.ini
</p><p>8) Have a look at the bunch of png images. If you issue the command
</p><p>xv&nbsp; *png
</p><p>you can quickly pass images forward by pressing the space key, and backwards
<br>pressing the backspace key.&nbsp; <br>
</p>
<p>Generate an mpg or gif file with the convert
command (command line of the sort:<br>
convert p1_anim???.png&nbsp; name.mpg&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp; <br>
convert p1_anim???.png&nbsp; name.gif&nbsp; )
</p>
<p>9) In the just created animation, we made the 3 Euler's angles change
linearly with time,
<br>as the <i>clock</i> value grows uniformly between the values defined
in <b>p1_anim.ini</b>, and the
<br>lines
</p><p><b>// #declare Factor=sin(pi*clock)*sin(pi*clock);</b>
<br><b>#declare Factor=clock;</b>
</p><p>make trivially Factor to be equal to <i>clock</i>. Create a new animation
in which the rotation angles
<br>Factor*f1x&nbsp;&nbsp; Factor*f1y&nbsp; Factor*f1z<b>&nbsp;</b>&nbsp;
follow a time dependence of the kind sin^2(t), just
<br>commenting and uncommenting the appropriate lines declaring the <b>Factor</b>
variable in the
<br>file <b>p1_anim.pov </b>.
</p>
<p><br>
10 ) Finally repeat the above points using one of the rotations specified in
the files <b>final/rijxcolumnes</b>* ,<br>
using two different Euler angles characterizations, one following the conventional ordering:<br>
R1(z,fi_z) R2(y,fi_y) R3(x,fi_x), and another one using three elementary rotations chosen at<br>
your discretion. You will need to reflect that order in the .pov file accordingly.<br>
&nbsp;

</p>


Hand out a report describing the two parameterizations you used for the general rotation matrix, problems <br>
encountered (if any),&nbsp; your code for calculating the Euler angles in the two ordering versions, a brief <br>
description of the changes introduced in the .pov files, and the animated sequences. <br>
</body></html>